<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
    <title>Quail Runner</title>
    <style>
        :root { --safe-area-top: env(safe-area-inset-top, 0px); }
        body {
            margin: 0;
            padding: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            /* Prefer viewport-height units that work well in Safari with toolbars/tabs */
            height: 100vh;   /* fallback */
            height: 100svh;  /* iOS Safari small viewport (no overlay by bars) */
            height: 100dvh;  /* dynamic viewport for modern browsers */
            font-family: 'Courier New', monospace;
            overflow: hidden;
            touch-action: none;
        }
        canvas {
            border: 2px solid #333;
            background: #1a1a2e;
            display: block;
        }
        /* instructions removed */
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="932" height="430"></canvas>

    <script>
        // Game setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Viewport-aware UI offset: accounts for top browser UI (iOS/Android)
        let uiTopOffset = 0;
        function getCSSPx(name) {
            const cs = getComputedStyle(document.documentElement);
            const v = cs.getPropertyValue(name).trim();
            const n = parseFloat(v);
            return isNaN(n) ? 0 : n;
        }
        function computeUITopOffset() {
            const vv = window.visualViewport;
            const safeTop = getCSSPx('--safe-area-top');
            const overlayTop = vv ? Math.max(vv.offsetTop || 0, 0) : safeTop;
            const rect = canvas.getBoundingClientRect();
            // How much of the top overlay overlaps the canvas top edge
            const overlap = Math.max(0, overlayTop - rect.top);
            // Canvas CSS pixels match canvas coordinate space here, so use overlap directly
            uiTopOffset = Math.round(Math.min(overlap, canvas.height * 0.5));
        }
        // Keep the offset fresh on viewport changes
        const recomputeOffset = () => computeUITopOffset();
        window.addEventListener('resize', recomputeOffset, { passive: true });
        window.addEventListener('orientationchange', recomputeOffset, { passive: true });
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', recomputeOffset, { passive: true });
            window.visualViewport.addEventListener('scroll', recomputeOffset, { passive: true });
        }
        
        // Load sprite images
        const quailSprite = new Image();
        quailSprite.src = 'assets/quail-sprites.png';
        const toastySprite = new Image();
        toastySprite.src = 'assets/toasty-botts.png';
        
        // Game constants
        const GRAVITY = 0.8;
        const GROUND_Y = canvas.height - 80;
        const QUAIL_X = 93; // 10% of canvas width (932 * 0.1)
        
        // Animation constants
        let animationFrame = 0;
        let animationTimer = 0;
        
        // Game state
        let gameRunning = false;
        let gameSpeed = 6;
        let score = 0;
        let jumpedEnemies = 0;
        let keys = {};
        let lastTap = 0;
        let chargingJump = false;
        let chargeAmount = 0;
        let touchStartTime = 0;
        let touchCharging = false;
        let keydownStartTime = 0;
        let spaceHeld = false;
        let georgiaRBMode = false; // Special invincible mode
        let prevDisplaySpeed = 0;   // Track displayed speed for threshold crossing
        let quailTextBounds = null; // Bounding box of the word "QUAIL" on start screen
        
        // Game objects
        let quail = {
            x: QUAIL_X,
            y: GROUND_Y - 35, // start ~10px above ground with larger sprite
            width: 60,        // 50% larger
            height: 45,       // 50% larger
            velocityY: 0,
            velocityX: 0,
            isGrounded: true,
            canDoubleJump: false
        };
        
        let enemies = [];
        let trails = [];
        let confetti = [];
        let toastyEffect = null;
        
        // Draw functions
        // Background gradient + starfield
        let stars = [];
        let starTick = 0;
        function initStars(count = 120) {
            stars = [];
            for (let i = 0; i < count; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * (GROUND_Y - 10),
                    speed: 0.3 + Math.random() * 1.2,
                    size: Math.random() < 0.85 ? 1 : 2,
                    twinkle: Math.random() * Math.PI * 2
                });
            }
        }
        function updateStars() {
            starTick += 0.05;
            for (let s of stars) {
                s.x -= s.speed;
                if (s.x < -2) {
                    s.x = canvas.width + Math.random() * 20;
                    s.y = Math.random() * (GROUND_Y - 10);
                    s.speed = 0.3 + Math.random() * 1.2;
                    s.size = Math.random() < 0.85 ? 1 : 2;
                    s.twinkle = Math.random() * Math.PI * 2;
                }
            }
        }
        function drawBackground() {
            const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
            grad.addColorStop(0, '#05040a');   // near black
            grad.addColorStop(0.5, '#1b1033'); // deep purple
            grad.addColorStop(1, '#3e1f59');   // richer purple
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        function drawStars() {
            ctx.save();
            for (let s of stars) {
                const a = 0.6 + 0.4 * Math.sin(starTick + s.twinkle);
                ctx.fillStyle = `rgba(255,255,255,${a.toFixed(3)})`;
                ctx.fillRect(Math.round(s.x), Math.round(s.y), s.size, s.size);
            }
            ctx.restore();
        }
        initStars(140);

        function drawQuail() {
            if (quailSprite.complete) {
                // Simple bobbing animation using the base sprite
                let offsetY = 0;
                if (gameRunning && quail.isGrounded) {
                    // Update animation
                    animationTimer++;
                    if (animationTimer > 10) { // Change frame every 10 game ticks
                        animationFrame = (animationFrame + 1) % 4;
                        animationTimer = 0;
                    }
                    // Create a simple bob effect
                    offsetY = Math.sin(animationFrame * Math.PI / 2) * 2;
                }
                
                // Draw sprite with slight stretching/squashing for running effect
                let scaleY = quail.isGrounded ? 1 + Math.sin(animationFrame * Math.PI / 2) * 0.1 : 1;
                let scaleX = quail.isGrounded ? 1 - Math.sin(animationFrame * Math.PI / 2) * 0.05 : 1;
                
                ctx.save();
                ctx.translate(quail.x + quail.width/2, quail.y + quail.height/2);
                ctx.scale(scaleX, scaleY);
                ctx.drawImage(
                    quailSprite,
                    -quail.width/2, -quail.height/2 + offsetY,
                    quail.width, quail.height
                );
                ctx.restore();
            } else {
                // Fallback to rectangles
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(quail.x, quail.y, quail.width, quail.height);
                
                // Eye (gold)
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(quail.x + 8, quail.y + 5, 8, 8);
                
                // Beak (orange)
                ctx.fillStyle = '#FF8C00';
                ctx.fillRect(quail.x + 25, quail.y + 10, 10, 5);
            }
        }
        
        function drawEnemy(enemy) {
            // Main cassette body (red)
            ctx.fillStyle = '#DC143C';
            ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
            
            // Tape reels (dark red)
            ctx.fillStyle = '#8B0000';
            ctx.fillRect(enemy.x + 5, enemy.y + 3, 8, 8);
            ctx.fillRect(enemy.x + 17, enemy.y + 3, 8, 8);
            
            // Tape line
            ctx.fillRect(enemy.x + 5, enemy.y + 15, 20, 2);
        }
        
        function drawGround() {
            ctx.fillStyle = '#2d5a2d';
            ctx.fillRect(0, GROUND_Y, canvas.width, 80);
        }
        
        function drawTrails() {
            trails.forEach(trail => {
                const alpha = trail.life / trail.maxLife;
                const size = alpha * 8;
                
                ctx.fillStyle = `rgba(160, 32, 240, ${alpha * 0.8})`;
                ctx.fillRect(trail.x - size/2, trail.y - size/2, size, size);
            });
        }
        
        function drawConfetti() {
            confetti.forEach(piece => {
                ctx.save();
                ctx.translate(piece.x, piece.y);
                ctx.rotate(piece.rotation);
                const f = piece.fontSize || 16;
                ctx.font = `${f}px Arial`;
                const text = piece.emoji || 'üá∫üá∏';
                ctx.fillText(text, -f/2, f/2);
                ctx.restore();
            });
        }
        
        function drawUI() {
            ctx.save();
            // Normalize text rendering so UI is consistent from the start
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            
            // Base anchor positions (before adjustment)
            const baseScoreTop = 40 + uiTopOffset;
            const baseSpeedTop = 65 + uiTopOffset;
            const scoreFont = '24px Courier New';
            const speedFont = '16px Courier New';
            const scoreHeight = 24; // matches scoreFont size
            const speedHeight = 16; // matches speedFont size
            
            // Compute delta so: (speedTop + speedHeight) == (baseScoreTop + scoreHeight/2)
            const delta = (baseSpeedTop + speedHeight) - (baseScoreTop + scoreHeight / 2);
            const scoreTop = baseScoreTop - delta;
            const speedTop = baseSpeedTop - delta;
            
            // Score
            ctx.fillStyle = 'white';
            ctx.font = scoreFont;
            ctx.fillText(`Score: ${score}`, 60, scoreTop);
            
            // Speed.. but it's really distance
            ctx.font = speedFont;
            ctx.fillText(`Distance: ${Math.floor(gameSpeed * 50)}`, 60, speedTop);
            
            // Charge bar
            if (chargingJump || touchCharging) {
                const barWidth = chargeAmount * 100;
                ctx.fillStyle = 'yellow';
                ctx.fillRect(quail.x, quail.y - 20, barWidth, 8);
                ctx.strokeStyle = 'white';
                ctx.strokeRect(quail.x, quail.y - 20, 100, 8);
            }
            
            // Toasty effect
            if (toastyEffect && toastyEffect.timer > 0) {
                const scale = Math.min(toastyEffect.timer / 20, 1);
                ctx.save();
                ctx.translate(canvas.width - 120, 60 + uiTopOffset);
                ctx.scale(scale, scale);
                
                if (toastySprite.complete) {
                    // Calculate proper aspect ratio for toasty sprite
                    const aspectRatio = toastySprite.width / toastySprite.height;
                    const spriteHeight = 80;
                    const spriteWidth = spriteHeight * aspectRatio;
                    
                    // Draw toasty sprite with correct proportions
                    ctx.drawImage(toastySprite, -spriteWidth/2, -spriteHeight/2, spriteWidth, spriteHeight);
                    
                    // Add "TOASTY!" text below the sprite
                    ctx.fillStyle = 'yellow';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 2;
                    ctx.font = 'bold 20px Courier New';
                    ctx.textAlign = 'center';
                    ctx.strokeText('TOASTY!', 0, spriteHeight/2 + 25);
                    ctx.fillText('TOASTY!', 0, spriteHeight/2 + 25);
                } else {
                    // Fallback
                    ctx.fillStyle = 'rgba(255, 100, 100, 0.8)';
                    ctx.fillRect(-40, -25, 80, 50);
                    
                    // Toasty text
                    ctx.fillStyle = 'yellow';
                    ctx.font = 'bold 18px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText('TOASTY!', 0, 5);
                }
                
                ctx.restore();
            }
            
            ctx.restore();
        }

        function drawGeorgiaBanner() {
            if (!georgiaRBMode) return;
            ctx.save();
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.lineWidth = 3;
            ctx.strokeStyle = 'black';
            ctx.fillStyle = '#ff6347'; // tomato
            ctx.font = 'bold 22px Courier New';
            const y = 10 + uiTopOffset;
            const text = 'GEORGIA RB MODE üçë';
            ctx.strokeText(text, canvas.width / 2, y);
            ctx.fillText(text, canvas.width / 2, y);
            ctx.restore();
        }
        
        function drawStartScreen() {
            ctx.save();
            // Background overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Layout constants
            const titleFont = '32px Courier New';
            const subtitleFont = '18px Courier New';
            const instrFont = '16px Courier New';
            const titleH = 32;
            const subtitleH = 18;
            const instrH = 16;
            const gap = 12;
            const logoTitleGap = 16;

            // Compute logo size (maintain aspect and fit)
            let logoW = 0, logoH = 0;
            if (quailSprite.complete && quailSprite.width && quailSprite.height) {
                const maxW = canvas.width * 0.6;
                const maxH = canvas.height * 0.28;
                const scale = Math.min(maxW / quailSprite.width, maxH / quailSprite.height);
                logoW = Math.max(1, Math.floor(quailSprite.width * scale));
                logoH = Math.max(1, Math.floor(quailSprite.height * scale));
            }

            // Total block height (logo + texts) and top anchor for vertical centering
            const totalH = logoH + (logoH ? logoTitleGap : 0) + titleH + gap + subtitleH + gap + instrH;
            let topY = Math.round((canvas.height - totalH) / 2);

            // Draw logo
            if (logoH) {
                const x = (canvas.width - logoW) / 2;
                ctx.drawImage(quailSprite, x, topY, logoW, logoH);
                topY += logoH + logoTitleGap;
            }

            // Draw text, centered
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillStyle = 'yellow';
            ctx.font = titleFont;
            // Draw title
            const title = 'QUAIL RUNNER';
            ctx.fillText(title, canvas.width / 2, topY);
            // Compute bounds for the word "QUAIL" inside the centered title
            const fullW = ctx.measureText(title).width;
            const quailW = ctx.measureText('QUAIL').width;
            const titleStartX = canvas.width / 2 - fullW / 2;
            quailTextBounds = {
                x: titleStartX,
                y: topY,
                w: quailW,
                h: titleH
            };
            topY += titleH + gap;

            ctx.font = subtitleFont;
            ctx.fillText('Dodge the Red Tape!', canvas.width / 2, topY);
            topY += subtitleH + gap;

            ctx.font = instrFont;
            ctx.fillText('TAP or PRESS SPACE to start', canvas.width / 2, topY);

            ctx.restore();
        }
        
        function drawGameOver() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = 'red';
            ctx.font = '36px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2 - 60);
            
            ctx.fillStyle = 'white';
            ctx.font = '20px Courier New';
            ctx.fillText(`Final Score: ${score}`, canvas.width/2, canvas.height/2 - 20);
            ctx.fillText(`Enemies Jumped: ${jumpedEnemies}`, canvas.width/2, canvas.height/2 + 10);
            
            ctx.fillStyle = 'yellow';
            ctx.font = '16px Courier New';
            ctx.fillText('TAP or PRESS SPACE to restart', canvas.width/2, canvas.height/2 + 50);
            
            ctx.textAlign = 'left'; // Reset
        }
        
        // Game logic
        function jump(force = 18) {
            if (quail.isGrounded) {
                quail.velocityY = -force;
                quail.velocityX = 3; // Add horizontal movement when jumping
                quail.isGrounded = false;
                quail.canDoubleJump = true;
            } else if (quail.canDoubleJump) {
                quail.velocityY = -force * 0.8;
                quail.velocityX = 2; // Less horizontal movement for double jump
                quail.canDoubleJump = false;
            }
        }
        
        function spawnEnemy() {
            enemies.push({
                x: canvas.width + 50,
                y: GROUND_Y - 25,
                width: 30,
                height: 20,
                scored: false
            });
        }
        function spawnFlyingEnemy() {
            const width = 30;
            const height = 20;
            const margin = 6; // a few pixels above the player's height from ground
            const bottomY = GROUND_Y - quail.height - margin;
            const y = bottomY - height;
            enemies.push({
                x: canvas.width + 50,
                y,
                width,
                height,
                scored: false,
                flying: true
            });
        }
        
        function createTrail() {
            if (gameRunning) {
                // Create trail more frequently and make it follow quail position
                trails.push({
                    x: quail.x - 5,
                    y: quail.y + 15,
                    life: 90, 
                    maxLife: 90
                });
            }
        }
        
        function createConfetti(x, y, opts = {}) {
            const count = opts.count ?? 8;
            const emoji = opts.emoji ?? 'üá∫üá∏';
            const spread = opts.spread ?? 40;
            const speed = opts.speed ?? 4;
            const life = opts.life ?? 60;
            const fontSize = opts.fontSize ?? 16;
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const v = (Math.random() * 0.5 + 0.75) * speed;
                confetti.push({
                    x: x + (Math.random() - 0.5) * spread,
                    y: y + (Math.random() - 0.5) * spread,
                    velocityX: Math.cos(angle) * v,
                    velocityY: Math.sin(angle) * v - 2,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.2,
                    life,
                    emoji,
                    fontSize
                });
            }
        }

        function createPeachConfettiExplosion(cx, cy) {
            // Local explosion
            createConfetti(cx, cy, { count: 40, emoji: 'üçë', spread: 80, speed: 5, life: 80, fontSize: 18 });
            // Screen-wide shower
            for (let i = 0; i < 60; i++) {
                createConfetti(Math.random() * canvas.width, Math.random() * canvas.height, {
                    count: 1,
                    emoji: 'üçë',
                    spread: 10,
                    speed: 3,
                    life: 100,
                    fontSize: 16
                });
            }
        }
        
        function showToasty() {
            toastyEffect = { timer: 180 };
        }
        
        function update() {
            if (!gameRunning) return;
            
            // Update quail physics
            quail.velocityY += GRAVITY;
            quail.y += quail.velocityY;
            
            // Update horizontal movement
            quail.x += quail.velocityX;
            
            // Apply horizontal drag
            quail.velocityX *= 0.95;
            
            // Keep quail from moving too far right or left
            if (quail.x > QUAIL_X + 50) {
                quail.x = QUAIL_X + 50;
                quail.velocityX = 0;
            }
            if (quail.x < QUAIL_X - 20) {
                quail.x = QUAIL_X - 20;
                quail.velocityX = 0;
            }
            
            // Ground collision
            if (quail.y >= GROUND_Y - quail.height) {
                quail.y = GROUND_Y - quail.height;
                quail.velocityY = 0;
                quail.isGrounded = true;
                // Gradually return to original position when grounded
                if (quail.x > QUAIL_X) {
                    quail.x = Math.max(QUAIL_X, quail.x - 1);
                } else if (quail.x < QUAIL_X) {
                    quail.x = Math.min(QUAIL_X, quail.x + 1);
                }
            }
            
            // Create trail
            createTrail();
            
            // Update trails
            trails.forEach((trail, index) => {
                trail.life--;
                if (trail.life <= 0) {
                    trails.splice(index, 1);
                }
            });
            
            // Update confetti
            confetti.forEach((piece, index) => {
                piece.x += piece.velocityX;
                piece.y += piece.velocityY;
                piece.velocityY += 0.1; // gravity
                piece.rotation += piece.rotationSpeed;
                piece.life--;
                
                if (piece.life <= 0) {
                    confetti.splice(index, 1);
                }
            });
            
            // Update enemies - quarter speed (was gameSpeed * 0.5, now gameSpeed * 0.35)
            enemies.forEach((enemy, index) => {
                enemy.x -= gameSpeed * 0.35;
                
                // Check scoring
                if (!enemy.scored && enemy.x < quail.x - 20) {
                    enemy.scored = true;
                    score += 10;
                    jumpedEnemies++;
                    // Reward confetti (US flags): larger and more plentiful
                    createConfetti(enemy.x, enemy.y, { count: 16, fontSize: 24 });
                    
                    if (jumpedEnemies % 3 === 0) {
                        showToasty();
                    }
                }
                
                // Check collision
                if (enemy.x < quail.x + quail.width &&
                    enemy.x + enemy.width > quail.x &&
                    enemy.y < quail.y + quail.height &&
                    enemy.y + enemy.height > quail.y) {
                    if (georgiaRBMode) {
                        // Invincible: explode enemy into peaches
                        const cx = enemy.x + enemy.width / 2;
                        const cy = enemy.y + enemy.height / 2;
                        createPeachConfettiExplosion(cx, cy);
                        showToasty(); // always show toasty on collision in GEORGIA RB mode
                        enemies.splice(index, 1);
                    } else {
                        gameRunning = false;
                    }
                }
                
                // Remove off-screen enemies
                if (enemy.x < -50) {
                    enemies.splice(index, 1);
                }
            });
            
            // Update toasty effect
            if (toastyEffect) {
                toastyEffect.timer--;
                if (toastyEffect.timer <= 0) {
                    toastyEffect = null;
                }
            }
            
            // Update charge - only start charging after 160ms delay
            const currentTime = Date.now();
            
            // Handle keyboard charging
            if (spaceHeld && currentTime - keydownStartTime > 160 && quail.isGrounded) {
                if (!chargingJump) {
                    chargingJump = true;
                    chargeAmount = 0;
                }
            }
            
            // Handle touch charging
            if (touchStartTime > 0 && currentTime - touchStartTime > 160 && quail.isGrounded && !touchCharging) {
                touchCharging = true;
                chargeAmount = 0;
            }
            
            if (chargingJump || touchCharging) {
                chargeAmount = Math.min(chargeAmount + 0.02, 1);
            }
            
            // Increase game speed
            gameSpeed += 0.005;

            // Spawn a flying enemy when displayed speed crosses 1000
            const displaySpeedNow = Math.floor(gameSpeed * 50);
            if (prevDisplaySpeed <= 1000 && displaySpeedNow > 1000) {
                spawnFlyingEnemy();
            }
            prevDisplaySpeed = displaySpeedNow;
        }
        
        function draw() {
            // Recalculate UI offset each frame to track dynamic toolbars
            computeUITopOffset();
            // Clear canvas
            drawBackground();
            drawStars();
            
            if (gameRunning) {
                drawGround();
                drawTrails();
                drawQuail();
                enemies.forEach(drawEnemy);
                drawConfetti();
                drawUI();
            } else if (score > 0) {
                drawGround();
                drawQuail();
                enemies.forEach(drawEnemy);
                drawGameOver();
                drawUI();
            } else {
                drawGround();
                drawQuail();
                drawStartScreen();
            }
            // Mode banner draws in all states
            drawGeorgiaBanner();
        }
        
        function startGame() {
            gameRunning = true;
            score = 0;
            jumpedEnemies = 0;
            gameSpeed = 6;
            enemies = [];
            trails = [];
            confetti = [];
            toastyEffect = null;
            chargingJump = false;
            chargeAmount = 0;
            touchCharging = false;
            spaceHeld = false;
            keydownStartTime = 0;
            touchStartTime = 0;
            
            quail.x = QUAIL_X;
            // place just above ground allowing for sprite height
            quail.y = GROUND_Y - (quail.height - 20);
            quail.velocityY = 0;
            quail.velocityX = 0;
            quail.isGrounded = true;
            quail.canDoubleJump = false;
            
            // Reset animation
            animationFrame = 0;
            animationTimer = 0;
            
            // Start enemy spawning
            enemySpawnTimer = 0;
            // Spawn the first enemy immediately
            spawnEnemy();
            prevDisplaySpeed = 0;
        }
        
        // Game loop
        let enemySpawnTimer = 0;
        function gameLoop() {
            updateStars();
            update();
            draw();
            
            // Spawn enemies - 3x slower than before (increased timer from 90+random*90 to 270+random*270)
            if (gameRunning) {
                enemySpawnTimer++;
                if (enemySpawnTimer > 180 + Math.random() * 180) {
                    const displaySpeed = Math.floor(gameSpeed * 50);
                    if (displaySpeed > 1000 && Math.random() < 0.5) {
                        spawnFlyingEnemy();
                    } else {
                        spawnEnemy();
                    }
                    enemySpawnTimer = 0;
                }
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // Input handling
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                
                if (!gameRunning && score === 0) {
                    startGame();
                } else if (!gameRunning && score > 0) {
                    startGame();
                } else if (gameRunning) {
                    if (!spaceHeld) {
                        spaceHeld = true;
                        keydownStartTime = Date.now();
                        // Start potential charging; jump will occur on keyup
                        chargingJump = false;
                        chargeAmount = 0;
                    }
                }
            } else if (e.code === 'KeyG' || e.key === 'g' || e.key === 'G') {
                // Toggle Georgia RB mode
                georgiaRBMode = !georgiaRBMode;
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                const now = Date.now();
                const heldMs = now - (keydownStartTime || now);
                spaceHeld = false;
                
                if (gameRunning) {
                    if (chargingJump) {
                        // Charged jump on release
                        chargingJump = false;
                        const force = 15 + chargeAmount * 10;
                        quail.velocityY = -force;
                        quail.velocityX = 3 + chargeAmount * 2; // horizontal scales with charge
                        quail.isGrounded = false;
                        quail.canDoubleJump = true;
                        chargeAmount = 0;
                    } else {
                        // Quick tap -> normal jump (or double jump if airborne)
                        jump();
                    }
                }
            }
        });
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const now = Date.now();
            
            if (!gameRunning) {
                startGame();
            } else {
                // Double tap detection
                if (now - lastTap < 300) {
                    if (quail.canDoubleJump && !quail.isGrounded) {
                        jump();
                    }
                } else {
                    // Begin potential charging; jump will occur on touchend
                    touchStartTime = now;
                    touchCharging = false;
                    chargeAmount = 0;
                }
            }
            lastTap = now;
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            const now = Date.now();
            
            if (gameRunning) {
                const heldMs = now - (touchStartTime || now);
                if (touchCharging) {
                    // Charged jump on release
                    touchCharging = false;
                    const force = 15 + chargeAmount * 10;
                    quail.velocityY = -force;
                    quail.velocityX = 10 + chargeAmount * 2; // horizontal scales with charge
                    quail.isGrounded = false;
                    quail.canDoubleJump = true;
                    chargeAmount = 0;
                } else {
                    // Quick tap -> normal jump (or double jump if airborne)
                    jump();
                }
            }
            
            touchStartTime = 0;
        });
        
        canvas.addEventListener('click', (e) => {
            // Use click only to start/restart; gameplay jumps handled via touch/keyboard release
            if (!gameRunning) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const px = (e.clientX - rect.left) * scaleX;
                const py = (e.clientY - rect.top) * scaleY;
                // If on start screen (score === 0) and clicking the word QUAIL, enable GEORGIA RB mode
                if (score === 0 && quailTextBounds) {
                    const b = quailTextBounds;
                    if (px >= b.x && px <= b.x + b.w && py >= b.y && py <= b.y + b.h) {
                        georgiaRBMode = true;
                    }
                }
                startGame();
            }
        });

        // Mouse support for charge jump (press to charge, release to jump)
        canvas.addEventListener('mousedown', (e) => {
            if (gameRunning) {
                spaceHeld = true;
                keydownStartTime = Date.now();
                // Start potential charging; actual jump happens on mouseup
                chargingJump = false;
                chargeAmount = 0;
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (gameRunning) {
                const now = Date.now();
                const heldMs = now - (keydownStartTime || now);
                spaceHeld = false;
                if (chargingJump) {
                    // Charged jump on release (match keyboard behavior)
                    chargingJump = false;
                    const force = 15 + chargeAmount * 10;
                    quail.velocityY = -force;
                    quail.velocityX = 3 + chargeAmount * 2; // horizontal scales with charge
                    quail.isGrounded = false;
                    quail.canDoubleJump = true;
                    chargeAmount = 0;
                } else {
                    // Quick click -> normal jump (or double jump if airborne)
                    jump();
                }
            }
        });
        
        // Start the game
        gameLoop();
    </script>
</body>
</html>
